# Step by Step help on SimpleView1

This help is based on the simpleview1_reference-design. 

## Understand the SimpleView1 questions

Read the A3Q3 specifications and understand what it is required to do. Download the sample executable program, run and play with the program to see what it has (use right click mouse to bring up the menu). 

## Work plan

The estimated time to complete this question is 4-6 hours:

1. Download the simpleview1 reference design, read and understand the program structure. 

The program uses the so-called Model View Control (MVC) paradigm. 

- The model part is about 3D objects consisting of a hierarchy of classes of Point, Vector, Matrix, Shape, Cube, World. 

- The view part about image generation through OpenGL pipeline and display function. It involves Camera, SimpleView.cpp, and rendering of objects. 

- The control part is about user interactions through mouse actions on menu, and object transformations. It involves Camera, and mouse functions in SimpleView.cpp



2. Create cube class 

Implement the following methods in Cube.cpp

Cube::Cube()
{
	// set set coordinate values for all vertices
	// similar to slide 33 of Lecture 10. 
	
  vertex[0][0] = ??; vertex[0][1] = ??; vertex[0][2] = ??;
	.....
	
	// other faces
	face[0][0] = 0; face[0][1] = 1; face[0][2] = 2; face[0][3] = 3;
	.....
	
    r = 1.0;
    g = 1.0;
    b = 1.0;
}

void Cube::drawFace(int i)
{
// draw face i
	glColor3f(r, g, b);
	
// refer to slide 31 of lecture 10	

}

void Cube::draw()
{
    glPushMatrix();
    this->ctmMultiply();

    glScalef(s, s, s);
	    for (int i = 0; i < 6; i++) {
		    drawFace(i);
	    }
 
    glPopMatrix();
}


Compile and run, then you see the cube. 

You can scale the cube:  MCS transformations > Scale

You can also translate the cube:  WCS transformations > Translate x

Rotation does not work

3. Implement rotations

Develop the unimplemented matrix methods in Matrix.cpp with mouse action and move. (this is the difficult part of this assignment, you may spend more time on it) 


// multiplication  mat <- m * mat
void Matrix::matrixPreMultiply(Matrix* m) {
//  refer to slide 14 of lecture 8
}


// v  <- mat * v
void Matrix::multiplyVector(GLfloat* v) {
//  refer to slide 14 of lecture 8
}


void Matrix::rotateMatrix(GLfloat rx, GLfloat ry, GLfloat rz, GLfloat angle) {

// refer to slide 17 of lecture 8

}


In Shape.cpp


void Shape::rotate(GLfloat x0, GLfloat  y0, GLfloat  z0, GLfloat  rx, GLfloat  ry, GLfloat rz,  GLfloat  angle) {

	// translate to origin using tranlate vector (-x0, -y0, -z0)
	// rotate with parameter (rx, ry, rz, angle);
	// translate back to (x0, y0, z0);
}


Compile and run. You should be able to rotate cube in the WCS, and MCS

WCS transformations > Translate x
WCS transformations > Rotate z
MCS transformations > Rotate z


4. Camera transformations

Implement the following methods in Camera.cpp

void Camera::translate(GLfloat tx, GLfloat ty, GLfloat tz){ //w.r.p.t WC
  // add the tx, ty, tz to eye.x, eye.y, eye.z respectively. 
}

void Camera::rotate(GLfloat rx, GLfloat ry, GLfloat rz, GLfloat angle){ //w.r.p.t WC
	// create a Matrix m
	// change m to rotation matrix by call m.rotateMatrix(....)
	// Create vector v[4]
  // set v[] by eye's coordinates, v[3]=1;
	// call m.multiplyVector(v) to rotate v  to a new position
	// set eye coordinates by v's coordinates, now eye is at the rotated position. 
}

5. create the pyramid class and add to the World.cpp

6. Create house using one cube object and one pyramid object, scale and translate to proper positions. Put the the house in world. 


 

